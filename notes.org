* What's left:
** DONE add content length and content type header lines
** TODO timeout heuristic
** TODO adding HTTP status phrases (just a simple switch function)
** TODO error handling here and there
** TODO code cleanup
** TODO command line arguments
** TODO writeup
* Ideal high-level structure
    
  [accept] --q--> [respond]

  - [accept] is handled by a single greeter thread. The greeter simply accepts 
    connections and pushes the connection descriptor onto queue q1
  - [respond] is handled by a worker thread pool. These worker threads parse
    the request and send the appropriate response. They may send in chunks,
    but complete the entire response before taking on another request. This
    means there is no need (in this version) for any caching of parsing.
    - In HTTP/1.0, the worker threads should close the connection upon
      completion of each task.
    - In HTTP/1.1, the worker threads should place the connection back on
      the queue. They should also check if connection has timed out before
      processing each task.
  - Greeter thread should have higher scheduling priority than worker threads.
    This should ensure graceful degradation: server can still handle all
    incoming requests under high load (up to some fundamental limit out of
    my control), but just takes longer to respond to each request.

* Current restrictions/assumptions
  - requests do not have any headers or message body of importance
  - just do all blocking operations for now, then maybe go back and change
    threads to do non-blocking I/O

* To Do (given restrictions/assumptions)
** implement concurrent queue
** run simple test on queue with many threads
** implement proper headers (can do this last)
